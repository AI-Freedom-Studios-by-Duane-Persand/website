import { Injectable, NotFoundException, Logger, Inject, forwardRef } from '@nestjs/common';
import { CreateCampaignDto } from '../../../shared';
// Legacy engines removed - use V1 ContentGenerationService instead
// import { StrategyEngine } from '../engines/strategy.engine';
// import { CopyEngine } from '../engines/copy.engine';
import { SubscriptionsService } from '../subscriptions/subscriptions.service';
import { StorageService } from '../storage/storage.service';
import { ContentService } from './services/content.service';
import { CampaignRepository } from './repositories/campaign.repository';
import { TenantContextService } from '../infrastructure/context/tenant-context';
import { Transactional } from '../infrastructure/decorators/transactional.decorator';
import { CampaignDocument } from '../models/campaign.schema';

@Injectable()
export class CampaignsService {
  private readonly logger = new Logger(CampaignsService.name);

  constructor(
    private readonly campaignRepository: CampaignRepository,
    private readonly tenantContext: TenantContextService,
    // Legacy engines removed - use V1 ContentGenerationService
    // private readonly strategyEngine: StrategyEngine,
    // private readonly copyEngine: CopyEngine,
    private readonly subscriptionsService: SubscriptionsService,
    private readonly storageService: StorageService,
    @Inject(forwardRef(() => ContentService))
    private readonly contentService: ContentService
  ) {}

  @Transactional()
  async create(createCampaignDto: CreateCampaignDto & { createdBy: string; tenantId?: string }): Promise<any> {
    try {
      this.logger.log('Starting campaign creation process');

      // Get tenantId from context (automatically scoped from JWT)
      const tenantId = this.tenantContext.getTenantId();
      this.logger.log(`[create] tenantId=${tenantId}`);

      // Patch required fields for CreateCampaignDto compatibility
      const patchedDto = {
        ...createCampaignDto,
        title: (createCampaignDto as any).title || createCampaignDto.name || 'Untitled',
        description: (createCampaignDto as any).description || '',
        budget: (createCampaignDto as any).budget || 0,
        userId: (createCampaignDto as any).userId || createCampaignDto.createdBy || 'system',
      };

      // Generate initial strategy with Poe API, fallback on error
      // DEPRECATED: Migrated to V1 ContentGenerationService
      let strategy = 'Generated by V1 service';
      /*
      try {
        this.logger.log('[PoeAPI] Requesting strategy generation', patchedDto);
        strategy = await this.strategyEngine.generate(patchedDto);
        this.logger.log('[PoeAPI] Strategy generated successfully');
      } catch (err) {
        const errorMessage = (typeof err === 'object' && err !== null && 'message' in err) ? (err as any).message : undefined;
        const errorStack = (typeof err === 'object' && err !== null && 'stack' in err) ? (err as any).stack : undefined;
        this.logger.error('[PoeAPI] Strategy generation failed, using fallback.', {
          errorMessage,
          errorStack,
          err
        });
        strategy = 'Default strategy content';
        this.logger.warn('[PoeAPI] Using fallback strategy content:', strategy);
      }
      */

      // Generate initial copy with Poe API, fallback on error
      // DEPRECATED: Migrated to V1 ContentGenerationService
      let copy = 'Generated by V1 service';
      /*
      try {
        this.logger.log('[PoeAPI] Requesting copy generation', patchedDto);
        copy = await this.copyEngine.generate(patchedDto);
        this.logger.log('[PoeAPI] Copy generated successfully');
      } catch (err) {
        const errorMessage = (typeof err === 'object' && err !== null && 'message' in err) ? (err as any).message : undefined;
        const errorStack = (typeof err === 'object' && err !== null && 'stack' in err) ? (err as any).stack : undefined;
        this.logger.error('[PoeAPI] Copy generation failed, using fallback.', {
          errorMessage,
          errorStack,
          err
        });
        copy = 'Default copy content';
        this.logger.warn('[PoeAPI] Using fallback copy content:', copy);
      }
      */

      // Use a generated campaignId or fallback to name+timestamp
      const campaignId = (createCampaignDto as any).campaignId || `${createCampaignDto.name.replace(/\s+/g, '-')}-${Date.now()}`;

      // Upload generated strategy and copy to R2
      let strategyUrl, copyUrl;
      try {
        strategyUrl = await this.storageService.uploadFile(
          Buffer.from(strategy, 'utf-8'),
          `${campaignId}-strategy-v1.txt`,
          'text/plain'
        );
        this.logger.log(`[StorageService] Strategy uploaded to R2: ${strategyUrl}`);
      } catch (err) {
        const errorMessage = (typeof err === 'object' && err !== null && 'message' in err) ? (err as any).message : undefined;
        const errorStack = (typeof err === 'object' && err !== null && 'stack' in err) ? (err as any).stack : undefined;
        this.logger.error('[StorageService] Failed to upload strategy to R2', {
          errorMessage,
          errorStack,
          err
        });
        throw new Error('Failed to upload strategy to storage.');
      }

      try {
        copyUrl = await this.storageService.uploadFile(
          Buffer.from(copy, 'utf-8'),
          `${campaignId}-copy-v1.txt`,
          'text/plain'
        );
        this.logger.log(`[StorageService] Copy uploaded to R2: ${copyUrl}`);
      } catch (err) {
        const errorMessage = (typeof err === 'object' && err !== null && 'message' in err) ? (err as any).message : undefined;
        const errorStack = (typeof err === 'object' && err !== null && 'stack' in err) ? (err as any).stack : undefined;
        this.logger.error('[StorageService] Failed to upload copy to R2', {
          errorMessage,
          errorStack,
          err
        });
        throw new Error('Failed to upload copy to storage.');
      }

      // Build initial versioned structures
      const now = new Date();
      const initialStrategy = {
        version: 1,
        createdAt: now,
        createdBy: createCampaignDto.createdBy,
        platforms: (createCampaignDto as any).platforms || [],
        goals: (createCampaignDto as any).goals || [],
        targetAudience: (createCampaignDto as any).targetAudience || '',
        contentPillars: (createCampaignDto as any).contentPillars || [],
        brandTone: (createCampaignDto as any).brandTone || '',
        constraints: (createCampaignDto as any).constraints || '',
        cadence: (createCampaignDto as any).cadence || '',
        adsConfig: (createCampaignDto as any).adsConfig || {},
        invalidated: false,
      };

      const initialContent = {
        version: 1,
        createdAt: now,
        createdBy: createCampaignDto.createdBy,
        mode: (createCampaignDto as any).mode || 'ai',
        textAssets: [copyUrl],
        imageAssets: [],
        videoAssets: [],
        aiModel: (createCampaignDto as any).model || '',
        regenerationMeta: {},
        strategyVersion: 1,
        needsReview: false,
        invalidated: false,
      };

      const campaignData = {
        tenantId,
        name: createCampaignDto.name,
        status: 'draft',
        statusHistory: [{ status: 'draft', changedAt: now, changedBy: createCampaignDto.createdBy }],
        strategyVersions: [initialStrategy],
        contentVersions: [initialContent],
        assetRefs: [],
        schedule: [],
        approvalStates: {
          strategy: 'pending',
          content: 'pending',
          schedule: 'pending',
          ads: 'pending',
        },
        revisionHistory: [{
          revision: 1,
          changedAt: now,
          changedBy: createCampaignDto.createdBy,
          changes: { created: true },
          note: 'Initial campaign creation',
        }],
      };

      let savedCampaign;
      try {
        savedCampaign = await this.campaignRepository.create(campaignData as any, tenantId);
        this.logger.log(`Campaign created successfully with ID: ${savedCampaign._id}`);
      } catch (err) {
        const errorMessage = (typeof err === 'object' && err !== null && 'message' in err) ? (err as any).message : undefined;
        const errorStack = (typeof err === 'object' && err !== null && 'stack' in err) ? (err as any).stack : undefined;
        this.logger.error('[MongoDB] Failed to save new campaign', {
          errorMessage,
          errorStack,
          err,
          campaignData
        });
        throw new Error('Failed to save campaign to database.');
      }
      return savedCampaign;
    } catch (error) {
      const errorMessage = (typeof error === 'object' && error !== null && 'message' in error) ? (error as any).message : undefined;
      const errorStack = (typeof error === 'object' && error !== null && 'stack' in error) ? (error as any).stack : undefined;
      this.logger.error('Error during campaign creation', {
        errorMessage,
        errorStack,
        error,
        input: createCampaignDto
      });
      throw new Error('Failed to create campaign. Please try again later.');
    }
  }

  // Add a new strategy version and invalidate downstream approvals/content
  async addStrategyVersion(campaignId: string, strategyData: any, userId: string, note?: string, tenantId?: string) {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    const campaign = await this.campaignRepository.findById(campaignId, resolvedTenantId);
    if (!campaign) throw new NotFoundException('Campaign not found');
    const newVersion = (campaign.strategyVersions?.length || 0) + 1;
    const now = new Date();
    campaign.strategyVersions.push({ ...strategyData, version: newVersion, createdAt: now, createdBy: userId, invalidated: false });
    // Invalidate all content/schedule/ads approvals
    campaign.approvalStates.strategy = 'pending';
    campaign.approvalStates.content = 'needs_review';
    campaign.approvalStates.schedule = 'needs_review';
    campaign.approvalStates.ads = 'needs_review';
    // Mark all content versions as invalidated
    if (campaign.contentVersions) {
      campaign.contentVersions.forEach((c: any) => { c.invalidated = true; c.invalidatedAt = now; c.invalidatedBy = userId; });
    }
    campaign.status = 'draft';
    campaign.statusHistory.push({ status: 'draft', changedAt: now, changedBy: userId, note });
    campaign.revisionHistory.push({ revision: (campaign.revisionHistory?.length || 0) + 1, changedAt: now, changedBy: userId, changes: { strategyVersion: newVersion }, note });
    const updated = await this.campaignRepository.updateById(campaign._id, campaign, resolvedTenantId);
    return updated;
  }

  // Add a new content version (AI/manual/hybrid)
  async addContentVersion(campaignId: string, contentData: any, userId: string, note?: string, tenantId?: string) {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    const campaign = await this.campaignRepository.findById(campaignId, resolvedTenantId);
    if (!campaign) throw new NotFoundException('Campaign not found');
    const newVersion = (campaign.contentVersions?.length || 0) + 1;
    const now = new Date();
    campaign.contentVersions.push({ ...contentData, version: newVersion, createdAt: now, createdBy: userId, invalidated: false });
    campaign.approvalStates.content = 'pending';
    campaign.status = 'draft';
    campaign.statusHistory.push({ status: 'draft', changedAt: now, changedBy: userId, note });
    campaign.revisionHistory.push({ revision: (campaign.revisionHistory?.length || 0) + 1, changedAt: now, changedBy: userId, changes: { contentVersion: newVersion }, note });
    const updated = await this.campaignRepository.updateById(campaign._id, campaign, resolvedTenantId);
    return updated;
  }

  // Approve a section (strategy, content, schedule, ads)
  async approveSection(campaignId: string, section: string, userId: string, note?: string, tenantId?: string) {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    const campaign = await this.campaignRepository.findById(campaignId, resolvedTenantId);
    if (!campaign) throw new NotFoundException('Campaign not found');
    campaign.approvalStates[section] = 'approved';
    const now = new Date();
    campaign.statusHistory.push({ status: `approved_${section}`, changedAt: now, changedBy: userId, note });
    campaign.revisionHistory.push({ revision: (campaign.revisionHistory?.length || 0) + 1, changedAt: now, changedBy: userId, changes: { approved: section }, note });
    const updated = await this.campaignRepository.updateById(campaign._id, campaign, resolvedTenantId);
    return updated;
  }

  // Rollback to a previous revision
  async rollbackToRevision(campaignId: string, revision: number, userId: string, note?: string, tenantId?: string) {
    // This is a stub for rollback logic; would require storing full snapshots or diffs
    // For now, just log the intent
    this.logger.warn(`Requested rollback of campaign ${campaignId} to revision ${revision} by ${userId} in tenant ${tenantId}`);
    // Implement actual rollback logic as needed
    return { message: 'Rollback not yet implemented' };
  }

  async findAll(tenantId?: string): Promise<any[]> {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    return this.campaignRepository.find({}, resolvedTenantId);
  }

  async findOne(id: string, tenantId?: string): Promise<any> {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    const campaign = await this.campaignRepository.findById(id, resolvedTenantId);
    if (!campaign) {
      throw new NotFoundException(`Campaign with ID ${id} not found`);
    }
    return campaign;
  }

  @Transactional()
  async update(id: string, updateData: Partial<any>, tenantId?: string, userId?: string): Promise<any> {
    try {
      const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
      // Fetch the existing campaign first to detect strategy changes
      const existingCampaign = await this.campaignRepository.findById(id, resolvedTenantId);
      if (!existingCampaign) {
        throw new NotFoundException(`Campaign with ID ${id} not found`);
      }

      // Detect if strategy-related fields are being updated
      const strategyFieldsChanged = this.detectStrategyChanges(existingCampaign, updateData);
      
      // Apply the update
      const updatedCampaign = await this.campaignRepository.updateById(
        id,
        updateData,
        resolvedTenantId,
      );
      
      if (!updatedCampaign) {
        throw new NotFoundException(`Campaign with ID ${id} not found`);
      }

      // If strategy changed, automatically generate new content assets
      if (strategyFieldsChanged && userId) {
        this.logger.log(`Strategy changed for campaign ${id}, triggering asset regeneration`);
        
        // Trigger async asset generation (non-blocking)
        this.regenerateAssetsAfterStrategyChange(id, resolvedTenantId, userId).catch(err => {
          this.logger.error(`Failed to regenerate assets for campaign ${id}: ${err.message}`, err.stack);
        });
      }

      this.logger.log(`Campaign updated successfully with ID: ${id}`);
      return updatedCampaign;
    } catch (error) {
      this.logger.error('Error during campaign update', error instanceof Error ? error.stack : error);
      throw new Error('Failed to update campaign. Please try again later.');
    }
  }

  /**
   * Detect if strategy-related fields have changed
   */
  private detectStrategyChanges(existing: any, updates: Partial<any>): boolean {
    const strategyFields = [
      'name',
      'platforms', 
      'goals',
      'targetAudience',
      'contentPillars',
      'brandTone',
      'constraints',
      'cadence',
      'adsConfig'
    ];

    return strategyFields.some(field => {
      if ((updates as any)[field] !== undefined) {
        const existingValue = JSON.stringify((existing as any)[field]);
        const newValue = JSON.stringify((updates as any)[field]);
        return existingValue !== newValue;
      }
      return false;
    });
  }

  /**
   * Regenerate assets after strategy changes
   */
  private async regenerateAssetsAfterStrategyChange(campaignId: string, tenantId: string, userId: string): Promise<void> {
    try {
      this.logger.log(`[regenerateAssetsAfterStrategyChange] Starting for campaign ${campaignId}`);
      
      // Get the campaign to check if it has existing content
      const campaign = await this.campaignRepository.findById(campaignId, tenantId);
      if (!campaign) {
        this.logger.warn(`Campaign ${campaignId} not found for asset regeneration`);
        return;
      }

      // Check if campaign has any content versions
      const hasExistingContent = campaign.contentVersions && campaign.contentVersions.length > 0;

      if (hasExistingContent) {
        // Regenerate images and videos (preserve text content)
        this.logger.log(`Regenerating images and videos for campaign ${campaignId}`);
        
        await this.contentService.regenerateContent({
          campaignId,
          tenantId,
          userId,
          regenerationType: 'images',
          aiModel: 'gpt-4o',
          preserveExisting: false,
        });

        await this.contentService.regenerateContent({
          campaignId,
          tenantId,
          userId,
          regenerationType: 'videos',
          aiModel: 'gpt-4o',
          preserveExisting: false,
        });

        this.logger.log(`Asset regeneration completed for campaign ${campaignId}`);
      } else {
        // Generate initial content if no content exists
        this.logger.log(`Generating initial content for campaign ${campaignId}`);
        
        await this.contentService.regenerateContent({
          campaignId,
          tenantId,
          userId,
          regenerationType: 'all',
          aiModel: 'gpt-4o',
          preserveExisting: false,
        });

        this.logger.log(`Initial content generation completed for campaign ${campaignId}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const errorStack = error instanceof Error ? error.stack : undefined;
      this.logger.error(
        `[regenerateAssetsAfterStrategyChange] Error for campaign ${campaignId}: ${errorMessage}`,
        errorStack
      );
      throw error;
    }
  }

  @Transactional()
  async delete(id: string, tenantId?: string): Promise<any> {
    const resolvedTenantId = tenantId || this.tenantContext.getTenantId();
    const deletedCampaign = await this.campaignRepository.deleteById(id, resolvedTenantId);
    if (!deletedCampaign) {
      throw new NotFoundException(`Campaign with ID ${id} not found`);
    }
    return deletedCampaign;
  }

  async createCampaignId(): Promise<{ id: string }> {
    try {
      this.logger.log('Creating campaign ID');

      // Simulate campaign ID creation logic
      const campaignId = `campaign-${Date.now()}`;

      this.logger.log(`Campaign ID created successfully: ${campaignId}`);
      return { id: campaignId };
    } catch (error) {
      this.logger.error('Error creating campaign ID', error instanceof Error ? error.stack : error);
      throw new Error('Failed to create campaign ID. Please try again later.');
    }
  }
}
